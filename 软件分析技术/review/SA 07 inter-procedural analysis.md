考虑过程调用的分析，有时又称为全程序分析Whole Program Analysis

### 基本思路
对不同过程采用不同抽象域，在调用和返回的时候添加结点来转换信息

上述思路的精度损失：会考虑不可能路径上的执行轨迹，会将A()函数的分析结果引入C()函数，反之亦然

### 基于克隆的上下文敏感分析
上下文非敏感分析Context-insensitive analysis 
	在**过程调用**的时候忽略调用的上下文 
上下文敏感分析Context-sensitive analysis 
	在**过程调用**的时候考虑调用的上下文
	
调用栈决定了不同的返回位置，但调用栈的可能长度是无限的 
- 如果有深层次重复函数，就会出现指数爆炸 
- 递归调用无法处理

解决方案：只使用最近k次调用（以及结束的调用不算）区分上下文，如果最近k次调用的位置都相同，则不复制，否则复制


### CFL可达性分析
精确的上下文敏感分析

##### Dyck-CFL
括号匹配的上下文无关语言
```
S ->  {_1 S }_1
	| {_2 S }_2
	| ...
	| SS
	| epsilon
```

给系统中的每一处调用分配唯一一对括号

给定一条路径，如果该路径上的符号组成Dyck-CFL 的句子，则该路径是可行路径

##### 数据流分析的分配性
给定任意满足分配性的数据流分析 $X$，其entry结点的初值是 $I^X$ ， 令Y和Z为仅有初值不同的数据流分析，其中 $Y$ 和 $Z$ 的初值分别是 $I^Y,I^Z$，且 $I^X=I^Y\sqcup I^Z$

令 $OUT_v^X$ 为通过 $X$ 分析得出的 $v$ 结点的值，则：$OUT_v^X=OUT_v^Y\sqcup OUT_v^Z$

可以把整个数据流分析转成**可达性问题**

##### 上下文无关语言可达性问题
给定一个图，其中每条边上有标签，给定一个用上下文无关文法描述的语言，对于图中任意结点$v_1$、$v_2$，确定是否存在从 $v_1$ 到 $v_2$的路径 $p$，使得该路径上的标签组成了 $L$ 中的句子

计算方法：把原文法改写为右边只有最多两个符号的形式
```
S ->  {_1 E_1         E_1 -> S }_1
	| {_2 E_2         E_2 -> S }_1
	| ...
	| epsilon
```

##### 精确性
CFL-Reachability 分析的结果就是所有可达路径的结果的合并

### 过程间分析两种典型加速技术
基于动态规划的加速技术 
- 通过记录之前计算过的信息来加速
- 又叫做Top-down Summary、Tabulating Algorithm等 
基于函数摘要的加速技术  
- 通过对函数内部的函数进行合并来加速 
- 通常用于提前对于函数库等进行分析
- 在选择合适的函数表示的时候，也可以加快分析执行 
- 也叫作Bottom-up Summary、Functional Analysis、 Modular Analysis等

### 从不等式到方程组
解不等式的unification算法

不等式 $$\begin{aligned}
&F_{v_1}(D_{v_1},D_{v_2},\cdots,D_{v_n})\:{\sqsubseteq}\:D_{v_1}\\
&F_{v_2}(D_{v_1},D_{v_2},\cdots,D_{v_n})\:{\sqsubseteq}\:D_{v_2}\\
&\cdots\\
&F_{v_n}(D_{v_1},D_{v_2},\cdots,D_{v_n})\:{\sqsubseteq}\:D_{v_n}\\
\end{aligned}
$$可以通过转换成如下方程组求解$$\begin{aligned}
&D_{v_1}=D_{v_1}\sqcup F_{v_1}(D_{v_1},D_{v_2},\cdots,D_{v_n})\\
&D_{v_2}=D_{v_2}\sqcup F_{v_2}(D_{v_1},D_{v_2},\cdots,D_{v_n})\\
&\cdots\\
&D_{v_n}=D_{v_n}\sqcup F_{v_n}(D_{v_1},D_{v_2},\cdots,D_{v_n})\\
\end{aligned}$$
