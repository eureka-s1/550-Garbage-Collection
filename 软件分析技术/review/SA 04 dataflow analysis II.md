### 数据流分析框架
[[slides04_dataflow_analysis_II.pdf|slides]]
#### 数据流分析单调框架
对前面所述算法以及所有同类算法的一个通用框架

目标：通过配置框架的参数，可以导出各种类型 的算法，并保证算法的安全性、终止性、合流性

为保证收敛性：
- 需要对抽象域的值加以限定 
- 需要对转换函数加以限定

数据流分析单调框架：
- 一个控制流图$(𝑉, 𝐸)$
- 一个有限高度的[[第14章 格与布尔代数#有界格|有界半格]] $(S,\sqcup,\perp)$
- 一个entry的初值 $𝑂𝑈𝑇_{entry}$
- 一组单调函数，对任意$v\in V-entry$ 存在一个 单调函数$f_v$

数据流分析**工单(WorkList)** 算法
```
//数据流分析的标准代码
for v in (V - entry): OUT_v = ⊥//初值
ToVisit = V - entry // 为什么
While (ToVisit.size > 0) {
	v in ToVisit  // 任意
	ToVisit -= v
	IN_v = ⊔ for w in pred(v) OUT_w
	if (OUT_v != f_v(IN_v)) ToVisit ∪= succ(v)
	OUT_v = f_v(IN_v)
}
```

**数据流分析收敛性** ：
定义如下轮询函数$$\begin{aligned}
F(OUT_{v_1},&OUT_{v_2},\cdots,OUT_{v_n})=\\
&\Big(f_{v_1}(\sqcup_{w\in pred(v_1)}OUT_w),\\
&f_{v_2}(\sqcup_{w\in pred(v_2)}OUT_w),\\
&\cdots,\\
&f_{v_n}(\sqcup_{w\in pred(v_n)}OUT_w)\Big),\\
\end{aligned}
$$容易证明，$F$ 是单调函数，根据不动点定理，反复在$(\perp,\cdots,\perp)$上应用 $F$ 所形成的链必然在有限步内终止，并且收敛于 $F$ 的最小不动点

$F$ 和工单算法的结果等价
	二者主要的区别是工单每次随机选择ToVisit中的节点更新

证明：
终止性：令 $OUT_v^i$ 为迭代第 $i$ 轮之后的 $OUT_v$ 值， $v$ 为任意结点，$OUT_v^0$，$OUT_v^1$，$\cdots$，是一个递增序列，即每次增大或不变。而格的高度有限，所以 $OUT_v$ 最多变化有限次，Tovisit 集合只有当结果变化才变为空集，所以足够长轮数必然变为空集

合流性：令 $X_i$ 为工单算法第 $i$ 轮的计算结果 $(OUT_{v_1}^i,OUT_{v_2}^i,\dots,OUT_{v_n}^i)$，$Y_i$ 为在 $(I,\perp,\dots ,\perp)$ 反复应用 $F$ 的序列，则 $X_i\sqsubseteq Y_i$ ，因此，当工单算法收敛时，收敛的结果是 $F$ 的最小不动点


**数据流分析的安全性**
数据流分析的输出值满足如下等式 $$OUT_v=f_v(\sqcup_{w\in pred(v)}OUT_w)$$
**数据流分析的分配性**
一个数据流分析满足分配性，如果$$\forall v \in V ,x,y\in S:f_v(x)\sqcup f_v(y)=f_v(x\sqcup y)$$
例如：
符号分析中的结点转换函数不满足分配性

在集合和交/并操作构成的有界半格中，给 定任意两个集合$GEN, KILL$，函数$f(OUT) = (OUT-KILL) \cup GEN$ 满足分配性

### 条件压缩函数
针对近似方案3：在控 制流路径分叉时，复制抽象状态到所 有分支，每个具体状态只能到达一个分支， 形成不精确

在每个分支添加条件压缩函数节点， 根据条件压缩抽象值

##### 反向执行语义
给定输出的抽象值，计算输入的抽象值：根据反向执行语义计算出变量的抽象值，然后和原来的值求 交

##### 更精确的反向执行语义
- **参考输入**的反向执行语义：给定输入输出的抽象值，压缩输入的抽象值
- 首先采用正向语义计算出表达式的值，然后再用反向语义压缩变量的值


##### 正向反向迭代
反向压缩变量的值之后，再进行一次正向反向流程可能得到更精确的值

如果反向语义函数保持**单调**，并且确保压缩或保持输入值，同时半格高度有限，那么该迭代过程一定收敛

### 加宽和变窄
##### 区间分析
正向分析，有界半格元素：程序中每个变量的区间，最小元为空集

合并操作：区间的并

变换函数：在区间上执行对应的加减操作

不满足单调框架条件：半格不是有限的

##### 区间分析改进
程序中的数字都是有上下界的，假设超过上下界 会导致程序崩溃

#### 加宽Widening
区间分析需要很多步才能达到收敛
	格的高度太高
	
加宽：通过降低结果的精度来加快收敛速度
	简易加宽：降低格的高度
	通用加宽：根据变化趋势快速猜测一个结果

#### 简易加宽
定义单调函数 $w$ 把结果进一步抽象：原始转换函数 $f$，新转换函数 $w\circ f$

如果 $x\sqsubseteq w(x)$ ，则分析结果保证安全

如果 $w$ 是单调函数，则简易加宽收敛

#### 通用加宽
更通用的加宽同时参考更新前和更新后的值来猜测最终会收敛的值
	引入加宽算子 $OUT_v\leftarrow OUT_v\nabla f_v(IN_v)$ 

如果 $y\sqsubseteq x\nabla y$ ，则通用加宽的分析结果保证安全性

$x\sqsubseteq x\nabla y$ 的作用？
	如果没有这个性质，则意味着下一轮的值可以比上一轮更小，可能导致震荡不终止

目前没有找到容易判断的属性来证明通用加宽的收敛性
	既不容易判断合流，也不容易判断终止

例如：更新顺序导致的不收敛

#### 变窄Narrowing
通过再次应用原始转换函数对加宽的结果进行修正

##### 变窄的安全性
原数据流分析的函数为 $F$，收敛于 $I_F$
经过加宽的函数为 $G$，收敛于 $I_G$

那么有：$I_F=F(I_F)\sqsubseteq F(I_G) \sqsubseteq G(I_G)=I_G$ ，即 $I_F\sqsubseteq F(I_G)\sqsubseteq I_G$，类似可得 $I_F\sqsubseteq F^k(I_G)\sqsubseteq I_G$

变窄**不保证收敛，也不保证终止**，通常需要针对应用证明收敛/终止性，或者只应用固定次数 $F$