##### 数据流分析的问题
1. 每个结点都要保存一份关于 $x,y,z$ 的值
2. 对每个元素，路径上的多余结点


### 稀疏分析

##### Def-Use 关系
给定变量 $x$，如果结点 A 可能改变 $x$ 的值，结点 B 可 能使用结点 A 改变后的$x$的值，则结点A和结点 B 存在定义-使用关系

##### 基于 Def-Use 关系的稀疏分析
每个结点只保存自己定义的变量的抽象值，只沿着定义-使用边传递抽象值，通常图上的边数大幅减少，图变得**稀疏**，分析速度大大高于原始数据流分析

假设结果基于集合的May分析，即返回的总是真实结果的超集
- 健壮性Soundness：用原数据流算法求出来的每一个结果新算法都会求出来
- 准确性Precision：用新算法求出来的每一个结果 原算法都会求出来

获取定义-使用关系的问题所在：
1. Reaching Definition的复杂度 $O(nm^2)$ ，本身就不够快，且额外实现比较麻烦
2. 在极端情况下，如果可能的定义较多，程序中的边会大幅增长（平方），分析速度反而变慢

### 静态单赋值形式 Single Static Assignment

每个变量都只被赋值一次（重命名）

当存在控制流导致的合流，引入函数 $\phi$ 代表根据不同的控制流选择不同的值
```
//example 
x=10; 
x+=y; 
if (x>10) 
	z=10; 
else 
	z=20; 
x+=z;

//SSA
x0=10; 
x1=x0+y; 
if (x1>10) 
	z0=10; 
else 
	z1=20; 
//x2=x1+z?;
z2=𝜙(z0, z1);
x2=x1+z2;
```

静态单赋值直接提供了定义-使用链（实际上不用真的建出来）
![[Pasted image 20241118120304.png|500]]

SSA 的性质：
- 静态单赋值存在高效算法，且通常编译器框架都支持静态单赋值形式
- 静态单赋值中的边不会平方增长
- 静态单赋值形式上的流非敏感分析与流敏感分析结果等价，换句话说，静态单赋值形式上的流非敏感分析与稀疏分析完全相同

##### 转换到静态单赋值形式
简单算法：每个基本块的头部对所有变量添加𝜙 函数，变量重命名
- 简单算法引入大量额外 $\phi$ 函数，实际图并没有变得稀疏，反而可能更加稠密

优化算法：ToDo

##### 转换回标准型
有些分析任务中我们需要再从静态单赋值转换回标准型
- 程序优化

转换过程就是删除掉静态单赋值中的 $\phi$ 函数

##### 实践中的静态单赋值形式
基于静态单赋值优化数据流分析的条件：需要分析的每一个内存位置一旦赋值都不会发生改变

解决办法：部分SSA

把内存位置分成两组，转换 SSA 的时候只转换能转换的组，并只对转换的组做优化
- Java 的情况：栈上的变量为优化组，堆上的变量为不优化组
- C 的情况：把变量分成address-taken和top-level的两组
	- address-taken：曾经被&取过地址的变量
	- top-level：从没被&取过地址的变量


未被取过地址的变量（top-level pointer），这类变量在LLVM IR中是register value，显式地编码为SSA形式。

被取过地址的变量（address-token variable），LLVM IR中是allocated memory objects，比较难去精确地计算这些内存变量的Def-Use关系。