
> $\text{“Testing shows the presence, not the absence of bugs.”}$ —— $\text{Edsger W. Dijkstra}$ 

**哥德尔不完备定理**：包含自然数和基本算术运算（如四则运算）的一致系统一定不完备，即包含一个无法证明的定理
- 完备性：对所有命题，该命题本身或其否定命题一定能被证明
- 一致性：任意命题和其否定命题不能同时被证明

**停机问题**：不存在一个算法能回答停机问题的所有实例

反证法：定义函数 `evil`
```
void Evil() {
	if (!Halt(Evil)) return ;
	else while(1);
}
```

**判定问题**：回答是/否的问题
**可判定问题**：是一个判定问题，该问题存在一个算法，使得对于该问题的每一个实例都给出是/否的答案。
- 停机问题是不可判定问题
- 确定程序有无内存泄露是不可判定问题

**莱斯定理**：把任意程序看成一个从输入到输出上的函数（或输入输出序偶的集合），该函数描述了程序的行为。关于该函数/集合的任何非平凡属性，都**不存在**可以检查该属性的通用算法。
- 平凡属性：要么对全体程序都为真，要么对全体程序都为假（没必要检查）
- 非平凡属性：不是平凡的所有属性

反证法：给定函数上的非平凡性质 P，假设空集（不输出的程序）不满足 P，且一定存在一个 `ok_prog` 满足性质 P。假设检测算法为 `P_holds` 

那么下述算法是能够检测程序 `q` 是否停机的：如果判定满足，说明 `q` 不停机，反之停机。与停机问题矛盾。
```
Bool halt(Program q) {
	void evil(Input n) {
		Output v = ok_prog(n);
		q();
		return v;
	}
	return P_holds(evil)
}
```

**有限**状态自动机：可判定的
状态数量过大：**近似法**

下近似：只输出“是”或“不知道”
上近似：只输出“否”或“不知道”

目标：尽可能多的回答“是”“否”，尽可能少的回答“不知道”

**非判定问题**通常可以转换为判定问题看待：假设正确答案是一个集合 S，如判断某个变量执行到某个位置的可能取值
- 对于每个值，回答判定问题：程序执行到这个位置是否可能出现这个值？
- must分析：返回的集合总是S的子集
- may分析：返回的集合总是S的超集
- 返回不相交集合 $\text{MUST,MAY,NEVER}$，其中 $\text{MUST}\subseteq \text{S}$ ，$\text{NEVER}\cap S=\varnothing$ ， $\text{S}\subseteq \text{MUST}\cup \text{MAY}$

must 和 may 的区分并不严格，可以相互转换

**正确性** $\text{Soundness}$： 一个逻辑系统得出结论，那么该结论是对的
**完整性** $\text{Completeness}$ ：对于所有对的结论，该逻辑系统都能推出来

*程序分析技术最早源自编译器优化*

#### 求近似解基本方法 

##### 抽象
给定表达式
```
term := term + term
 	 |  term - term
 	 |  term * term
 	 |  integer
 	 |  variable
```
和输入的符号，求输出的符号
定义
- 正={所有的正数}
- 负={所有的负数}
- 零={0}
- 槑={所有的整数和NaN}

##### 搜索
直接搜索效率较低，通常会引入各种剪枝和推断的方法

##### 抽象 vs 搜索
抽象通常考虑程序所有的执行，包括整个输入空间和任意长度的执行路径，但给出不精确的结果 
搜索通常只考虑一部分执行，包括有限的输入空间和有限的执行路径长度，但对于这部分执行给出精确的分析 

二者也可以结合