2300012969 盛梓航
### 半格
对于每个过程，考虑此过程的所有局部变量和全局变量，对于变量 $x$，全集为 $\{所有x定义语句位置\}$

抽象值：程序开始到当前可用的定义，may analysis 

初始值：空集

合并：集合并

### 变换函数
过程内的变换函数：
$f_v(甲)(x)=(甲(x)-KILL_v^x)\cup GEN_v^x$ 
- 对于赋值语句 x= 
	- $KILL_v^x=\{所有含 x 的定义\}$
	- $GEN_v^x=\{当前语句\}$
- 对于其他语句：$KILL_v^x=GEN_v^x=\{\}$


接下来考虑过程间
##### CALL 语句变换函数
假设函数为 $f(x_1,x_2,\cdots,x_n)$

调用参数为 $f(a_1,a_2,\cdots,a_n)$ ，$f_v(甲)(x_1)=(甲(x_1)-KILL_v^{x_1})\cup GEN_v^{x_1}$
其中$KILL_v^{x_1}=\{所有含 {x_1} 的定义\}$， $GEN_v^{x_1}=甲(a_1)$

对于其他变量，全局变量复制一遍，其他变量设为空集（此过程内的其他局部变量）

##### RETURN 语句变换函数
首先来考虑全局变量（实际上和过程间都类似），是会被更新的，记返回的抽象值为 $乙$

$f_v(甲)(x)=(甲(x)-KILL_v^x)\cup GEN_v^x$ 
其中 $x$ 是一个全局变量，$KILL_v^x=\{所有含 x 的定义\}$，$GEN_v^x=乙(x)$

其他变量 $y$ ，$f_v(甲)(y)=(甲(y)-KILL_v^y)\cup GEN_v^y$ 
- 对于语句 `y = f(..)`
	- $KILL_v^y=\{所有含 y 的定义\}$
	- $GEN_v^y=\{当前语句\}$
- 对于其他语句：$KILL_v^x=GEN_v^x=\{\}$


### 克隆分析
```
int g; 
void main(){ 
	int a = 10; 
	g=a+1;
	h(a); 
	h(a); 
}  
void h(int a) { 
	x(a); 
	g++; 
	x(a); 
}
void x(int a) {
	output(a);
}
```
重点在全局变量 $g$ 的定义变化，在第一次调用 $x(a)$ 时，$g$ 的定义是 `3: g=a+1` ，而在其他三次调用都是 `7: g++` ，为了区分 `context 3:7` 与其他三次调用，$k=2$ 是合适的

